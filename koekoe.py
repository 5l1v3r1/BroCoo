"""
Version         	 :           1.0.0
Developed by    :           Davy Boekhout
GitHub				 :			 https://github.com/zippy1990/BroCoo

Automating file extraction and analysis with
Cuckoo Sandbox, the Bro Network Security Monitor and Security Onion.

"""

import requests
import os.path
from pwd import getpwnam
import time
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import logging
import datetime
import sys
import hashlib

# -------------------------------These values can be safely changed-------------------------------
# Location of the Cuckoo API and Cuckoo webinterface to send requests to.
api_address = "http://IP_ADDRESS_CUCKOO_API:PORT"

cuckoo_host = "http://IP_ADDRESS_CUCKOO_HOST:PORT"

# If Cuckoo is not able to reliably analyze a file, they should be included in the list below
# ZIP is disallowed by default because of Cuckoos disabillity to handle this file properly.
disallowed_files = ["zip"]

# Maximum time limit that the script will run, used for error handling. Only change the first value.
# The second value is used to set an offset as the script waits 60 seconds before doing file analysis.
cuckoo_crit_timeout = 240

# The threshold that determines what action should be taken if any.
# A higher score means you won't be notified of less malicious files
# A very low score could result in false positives
score_threshold = 1.0

# Location for the log file that this script generates, default is based on Security Onion folder structure
# Can be changed to a location that suits the environment
log_dir = "/nsm/bro/logs/current/cuckoo.log"

# Name of the user that is using Bro / should take of logging
log_user = "sguil"

# ---------------------------These values should NOT be changed-----------------------------------
# API address to submit files to Cuckoo
create_url = api_address + "/tasks/create/file"

# API address to check if a file was already analyzed by Cuckoo based on a SHA256 hash
hash_url = api_address + "/files/view/sha256/"

# Used to determine the score of the given file
report_url = api_address + "/tasks/report/"

# Used to determine if the analysis failed
task_list = api_address + "/tasks/list/"

# Get the status information for a specific task
task_view = api_address + "/tasks/view/"

# File to analyze, is provided by Bro in the file extraction scripts
path_to_file = sys.argv[1]

# Getting the current date for logging purposes
cur_date = datetime.datetime.now()

# Get the full file name without other path values
file_name = os.path.basename(path_to_file)

# File extension is split from file_name to determine what kind of file we are dealing with
file_extension = file_name.split(".", 1)[1]

# Get the uid of the normal user
uid_log_user = getpwnam(log_user).pw_uid

# Get the gid of the normal user
gid_log_user = getpwnam(log_user).pw_gid


# Determine the SHA256 hash of the file that Bro extracted and return it
def get_hash():
    hash_256 = hashlib.sha256()
    with open(path_to_file, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_256.update(chunk)
    return hash_256.hexdigest()


# Based on a given hash, determine if the file has been analyzed before by Cuckoo,
# If it was analyzed before, return the score that it got the previous time.
def file_unique(sha_hash):
    file_info = []
    try:
        requests.get(hash_url + sha_hash).json()["sample"]["sha256"]
        hash_task_id = requests.get(hash_url + sha_hash).json()["sample"]["id"]
        hash_old_score = get_score(hash_task_id)
        file_info.append(hash_old_score)
        file_info.append(hash_task_id)
        return file_info
    # If it was not analyzed before, submit the file to Cuckoo and return the task_id for further use.
    except KeyError:
        submit_task_id = submit_file(path_to_file)
        return submit_task_id


# Submit file to Cuckoo Sandbox for analysis
def submit_file(file_path):
    with open(file_path, "rb") as sample:
        multipart_file = {"file": (file_name, sample)}
        retrieved_task_id = requests.post(create_url, files=multipart_file).json()["task_id"]
    return retrieved_task_id


# Try to get the report generated by Cuckoo and determine assigned score,
# if the file that was submitted is queued, wait for it to lose the "pending" status.
# Once the pending status is dropped, start the timer to determine if the cuckoo timeout has been reached
# if score is retrieved within the timeout frame, return it.
# Finally, if the score cannot be retrieved or some other timeout / error occurs, assume the analysis failed and
# return a score of 0.0.
def get_score(task):
    right_task = str(task)
    try:
        while requests.get(task_view + right_task).json()["task"]["status"] == 'pending':
            time.sleep(20)
    except ValueError:
            return 0.0
    analysis_start = time.time()
    while (time.time() - analysis_start) < cuckoo_crit_timeout:
        try:
            return requests.get(report_url + right_task).json()["info"]["score"]
        except KeyError:
            time.sleep(20)
    return 0.0


# Take action depending on retrieved score
# If file score is equal or greater than threshold, mail will be send to administrator
def take_action(file_score):
    if file_score >= score_threshold or file_extension in disallowed_files:
        action_taken = "mail_sent"
        send_mail(file_score, task_id, action_taken)
        return action_taken
    # File score below threshold means it can be deleted
    else:
        # os.unlink(path_to_file)
        action_taken = "file_deleted"
        return action_taken


# Send mail based on the analysis result of Cuckoo.
# disallowed_files is used to determine what kind of e-mail should be sent
def send_mail(retrieved_score, file_task_id, analysis_result):
    # Convert arguments so we can properly work with them
    retrieved_score = str(retrieved_score)
    file_task_id = str(file_task_id)

    # Link to the Cuckoo web interface so users can click directly to the report in the e-mail
    cuckoo_web_interface = cuckoo_host + "/analysis/" + file_task_id

    # Gather mail information
    mail_server = "MAIL_SERVER_ADDRESS"
    mail_from = "SENDER_MAIL_ADDRESS"
    recipients = ["RECIPIENT_1", "RECIPIENT_2"]

    # Create message container - the correct MIME type is multipart/alternative.
    msg = MIMEMultipart('alternative')
    msg['From'] = mail_from
    msg['To'] = ", ".join(recipients)

    if file_extension not in disallowed_files and analysis_result == "pass" or file_extension not in disallowed_files \
            and analysis_result == "mail_sent" or file_extension not in disallowed_files \
            and analysis_result == "mail_sent_again":
        if analysis_result == "mail_sent_again":
            msg['Subject'] = "Cuckoo result of %s with task ID " % file_name + file_task_id + \
                             " received a score of %s (again)" % retrieved_score
            # Create the body of the message (a plain-text message).
            text = "You can view the report at: %s\nNote: This file has been analyzed before" % cuckoo_web_interface
        else:
            msg['Subject'] = "Cuckoo result of %s with task ID " % file_name + file_task_id + \
                             " received a score of %s" % retrieved_score
            # Create the body of the message (a plain-text message).
            text = "You can view the report at: %s" % cuckoo_web_interface
    elif file_extension not in disallowed_files:
        if file_task_id == "None":
            msg['Subject'] = "Cuckoo ERROR: Cuckoo process failure"
            # Create the body of the message (a plain-text message).
            text = "While analyzing %s, a task ID of None was received, it's likely that the cuckoo.py process" \
                   " did not start correctly or has crashed.\nPlease check if cuckoo.py is running." % file_name
        else:
            msg['Subject'] = "Cuckoo ERROR: %s for %s with task ID %s" % (analysis_result, file_name, file_task_id)
            # Create the body of the message (a plain-text message).
            text = "Cuckoo ran into an error while analyzing %s and needs your attention.\n" \
                   "You can view the report at: %s" % (file_name, cuckoo_web_interface)
    else:
        # Create the body of the message (a plain-text message).
        if analysis_result == "mail_sent_again":
            msg['Subject'] = "Cuckoo detected a file with the %s extension (again)" % file_extension
            text = "Cuckoo cannot reliably analyze %s with task ID %s and therefore needs your attention.\n" \
                   "You can view the report at: %s\nNote: This file has been detected before"\
                   % (file_name, file_task_id, cuckoo_web_interface)
        else:
            msg['Subject'] = "Cuckoo detected a file with the %s extension" % file_extension
            text = "Cuckoo cannot reliably analyze %s with task ID %s and therefore needs your attention.\n" \
                   "You can view the report at: %s" % (file_name, file_task_id, cuckoo_web_interface)

    # Record the MIME type.
    part1 = MIMEText(text, 'plain')

    # Attach parts into message container.
    msg.attach(part1)

    # Send the message via defined SMTP server
    s = smtplib.SMTP(mail_server)

    # sendmail function takes 3 arguments: sender's address, recipient's address
    # and message to send - here the list of recipients is looped to send a mail to all included addresses
    for recipient in recipients:
        s.sendmail(mail_from, recipient, msg.as_string())

    s.quit()


# Error handling that accounts for different errors during file analysis
# The function is started by checking for errors in the report URL.
# If the report is not generated yet (because of a Cuckoo crash for example) the exception is raised
# From here on it checks if the task_list is reachable, which if it is, results in a failed_analysis.
# If both the report and task list are not available, the analysis was not started in the first place.
def error_handling(tmp_id):
    received_id = str(tmp_id)
    try:
        errors = requests.get(report_url + received_id).json()["debug"]["errors"]
        if len(errors) == 0:
            success = "pass"
            return success
        else:
            for error in errors:
                if "Machinery error" in error:
                    success = "vm_error"
                    return success
                elif "critical timeout" in error:
                    success = "crit_timeout"
                    return success
                else:
                    success = "undef_error"
                    return success
    except (KeyError, ValueError):
        success = "failed_analysis"
        return success


# Log actions taken by script to cuckoo.log. Specifically for files that were seen before.
def log_seen():
    log_format = "%(asctime)s\t%(old_id)s\t%(file_name)s\t%(file_hash)s\t%(seen)s\t%(score)s\t%(action)s"
    logging.basicConfig(filename=log_dir, level=logging.WARNING, format=log_format,
                        datefmt='%Y-%m-%d %H:%M:%S')
    logging.warning("", extra={'old_id': old_id, 'file_name': file_name, 'file_hash': file_hash, 'seen': 'true',
                               'score': old_score, 'action': action})


# Log actions taken by script to cuckoo.log. Specifically for files that were not seen before.
def log_not_seen():
    log_format = "%(asctime)s\t%(task_id)s\t%(file_name)s\t%(file_hash)s\t%(seen)s\t%(score)s\t%(action)s"
    logging.basicConfig(filename=log_dir, level=logging.WARNING, format=log_format,
                        datefmt='%Y-%m-%d %H:%M:%S')
    logging.warning("", extra={'task_id': task_id, 'file_name': file_name, 'file_hash': file_hash, 'seen': 'false',
                               'score': score, 'action': action})


if __name__ == "__main__":
    time.sleep(3)
    # [Start of script] get file hash and take appropriate action
    file_hash = get_hash()
    task_id = file_unique(file_hash)

    # Type of task_id determines what happens next
    if type(task_id) == list:
        # If the file was analyzed before, the results (score and id) was returned in a list
        # Here we check if we should send another mail for the previously analyzed file
        old_score = task_id[0]
        old_id = task_id[1]

        # After getting a task_id we can determine if the analysis was successful
        successful = error_handling(old_id)

        if successful == "pass":
            if old_score >= score_threshold or file_extension in disallowed_files:
                action = "mail_sent_again"
                send_mail(old_score, old_id, action)
            else:
                action = take_action(old_score)
        else:
            action = successful
            send_mail(old_score, old_id, action)

        # Check if a log file exists in log_dir and create it if it doesn't
        # Log actions taken by script in either case
        if not os.path.isfile(log_dir):
            with open(log_dir, 'w+') as logfile:
                logfile.write("date_time\ttask_id\tfile_name\tsha256_hash\tseen\tscore\taction\n")
            # Changing log ownership from root to normal user
            os.chown(log_dir, uid_log_user, gid_log_user)
            log_seen()
        else:
            log_seen()

        sys.exit(0)

    else:
        # Script should wait at least 60 seconds before trying to retrieve the report generated by Cuckoo
        # as we know for certain that the analysis is not done within 1 minute
        time.sleep(60)

        # The below function is used to retrieve the score, the current time in time_func_start is used
        # to terminate the script if it is taking too long.
        score = get_score(task_id)

        # After getting a task_id we can determine if the analysis was successful
        successful = error_handling(task_id)

        # Checking if the analysis was successful and taking further action
        if successful == "pass":
            action = take_action(score)
        else:
            action = successful
            send_mail(score, task_id, action)

        # Check if a log file exists in log_dir and create it if it doesn't
        # Log actions taken by script in either case
        if not os.path.isfile(log_dir):
            with open(log_dir, 'w+') as logfile:
                logfile.write("date_time\ttask_id\tfile_name\tsha256_hash\tseen\tscore\taction\n")
            # Changing log ownership from root to normal user
            os.chown(log_dir, uid_log_user, gid_log_user)
            log_not_seen()
        else:
            log_not_seen()

        sys.exit(0)
